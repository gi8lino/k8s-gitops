#!/usr/bin/env python3
"""Validate Flux dependsOn relations and generate dependency documentation.

This script scans YAML manifests for Flux `Kustomization` and `HelmRelease`
resources, checks that all `spec.dependsOn` targets exist, detects dependency
cycles per resource kind, and can emit Graphviz DOT/SVG plus a markdown summary.
"""

import argparse
import os
import re
import shutil
import subprocess
import sys
from collections import defaultdict

import yaml

RESOURCE_KINDS = ("Kustomization", "HelmRelease")


def node_key(kind: str, namespace: str, name: str) -> str:
    """Build a stable node identifier for a Flux resource."""
    return f"{kind}/{namespace}/{name}"


def dot_id(key: str) -> str:
    """Convert a node key into a Graphviz-safe identifier."""
    return re.sub(r"[^a-zA-Z0-9_]", "_", key)


def load_documents(path: str):
    """Load all YAML documents from a file and keep only mapping documents."""
    try:
        with open(path, "r", encoding="utf-8") as f:
            docs = list(yaml.safe_load_all(f))
        return [d for d in docs if isinstance(d, dict)]
    except Exception as exc:
        print(f"WARN: failed to parse {path}: {exc}", file=sys.stderr)
        return []


def find_cycle(nodes, edges):
    """Return one dependency cycle path if present, otherwise None."""
    graph = defaultdict(list)
    for src, dst in edges:
        graph[src].append(dst)

    visiting = set()
    visited = set()
    path = []

    def dfs(node):
        visiting.add(node)
        path.append(node)
        for neighbor in graph[node]:
            if neighbor in visiting:
                idx = path.index(neighbor) if neighbor in path else 0
                return path[idx:] + [neighbor]
            if neighbor in visited:
                continue
            cycle = dfs(neighbor)
            if cycle:
                return cycle
        path.pop()
        visiting.remove(node)
        visited.add(node)
        return None

    for n in nodes:
        if n in visited:
            continue
        cycle = dfs(n)
        if cycle:
            return cycle
    return None


def build_dot(resources, edges_by_kind):
    """Generate a Graphviz DOT graph for Flux resources and dependsOn edges."""
    lines = [
        "digraph flux_dependencies {",
        "  rankdir=LR;",
        "  graph [fontname=\"Helvetica\"];",
        "  node [shape=box, style=\"rounded,filled\", fillcolor=\"#f7f7f7\", fontname=\"Helvetica\"];",
        "  edge [fontname=\"Helvetica\"];",
        "",
    ]

    colors = {
        "Kustomization": "#3b82f6",
        "HelmRelease": "#16a34a",
    }

    for kind in RESOURCE_KINDS:
        lines.append(f"  subgraph cluster_{kind.lower()} {{")
        lines.append(f"    label=\"{kind}\";")
        lines.append("    color=\"#cccccc\";")
        nodes = sorted(
            ((k, v) for k, v in resources.items() if v["kind"] == kind),
            key=lambda kv: (kv[1]["namespace"], kv[1]["name"]),
        )
        for key, res in nodes:
            node = dot_id(key)
            label = f"{res['namespace']}/{res['name']}"
            lines.append(f'    {node} [label="{label}", color="{colors[kind]}"];')
        lines.append("  }")
        lines.append("")

    for kind in RESOURCE_KINDS:
        for src, dst in edges_by_kind[kind]:
            if src in resources and dst in resources:
                lines.append(f"  {dot_id(src)} -> {dot_id(dst)};")

    lines.append("}")
    lines.append("")
    return "\n".join(lines)


def edge_lines(kind, resources, edges):
    """Render human-readable edge lines for markdown documentation."""
    out = [f"### {kind} edges", ""]
    if not edges:
        out.append("- none")
        out.append("")
        return out
    for src, dst in sorted(edges):
        if src not in resources or dst not in resources:
            continue
        s = resources[src]
        d = resources[dst]
        out.append(f"- `{s['namespace']}/{s['name']}` -> `{d['namespace']}/{d['name']}`")
    out.append("")
    return out


def write_readme(path, dot_path, svg_path, resources, edges_by_kind):
    """Write markdown documentation that references generated graph artifacts."""
    dot_ref = os.path.relpath(dot_path, os.path.dirname(path)) if dot_path else "dependencies.dot"
    svg_ref = os.path.relpath(svg_path, os.path.dirname(path)) if svg_path else "dependencies.svg"
    content = [
        "# Flux Dependency Graph",
        "",
        "Generated by `hack/check_flux_dependencies.py`.",
        "",
        "Regenerate:",
        "",
        "```bash",
        "python3 ./hack/check_flux_dependencies.py --check \\",
        f"  --write-dot {dot_path} \\",
        f"  --write-svg {svg_path} \\",
        f"  --write-readme {path}",
        "```",
        "",
        f"- DOT source: `{dot_ref}`",
        f"- Rendered graph: `{svg_ref}`",
        "",
        f"![Flux dependency graph]({svg_ref})",
        "",
        f"- Total Flux resources: **{len(resources)}**",
        f"- Kustomization dependsOn edges: **{len(edges_by_kind['Kustomization'])}**",
        f"- HelmRelease dependsOn edges: **{len(edges_by_kind['HelmRelease'])}**",
        "",
    ]
    content.extend(edge_lines("Kustomization", resources, edges_by_kind["Kustomization"]))
    content.extend(edge_lines("HelmRelease", resources, edges_by_kind["HelmRelease"]))

    with open(path, "w", encoding="utf-8") as f:
        f.write("\n".join(content))


def render_svg(dot_path, svg_path):
    """Render an SVG from a DOT file using Graphviz `dot`."""
    dot_bin = shutil.which("dot")
    if not dot_bin:
        raise RuntimeError("Graphviz 'dot' command not found in PATH")
    subprocess.run([dot_bin, "-Tsvg", dot_path, "-o", svg_path], check=True)


def main():
    """CLI entrypoint for validation and dependency artifact generation."""
    parser = argparse.ArgumentParser(description="Check Flux dependsOn graph")
    parser.add_argument("--root", default="cluster", help="Root directory to scan (default: cluster)")
    parser.add_argument("--check", dest="check", action="store_true", default=True, help="Enable validation checks")
    parser.add_argument("--no-check", dest="check", action="store_false", help="Disable validation checks")
    parser.add_argument("--write-readme", help="Write dependency markdown summary to PATH")
    parser.add_argument("--write-dot", help="Write Graphviz DOT graph to PATH")
    parser.add_argument("--write-svg", help="Render Graphviz SVG graph to PATH (requires dot)")
    args = parser.parse_args()

    resources = {}
    edges_by_kind = {"Kustomization": [], "HelmRelease": []}
    errors = []

    for dirpath, _, filenames in os.walk(args.root):
        for filename in filenames:
            if not (filename.endswith(".yaml") or filename.endswith(".yml")):
                continue
            path = os.path.join(dirpath, filename)
            for doc in load_documents(path):
                api_version = str(doc.get("apiVersion", ""))
                kind = str(doc.get("kind", ""))
                if "toolkit.fluxcd.io" not in api_version or kind not in RESOURCE_KINDS:
                    continue

                meta = doc.get("metadata", {})
                name = str(meta.get("name", ""))
                namespace = str(meta.get("namespace", "default"))
                key = node_key(kind, namespace, name)

                resources[key] = {
                    "kind": kind,
                    "name": name,
                    "namespace": namespace,
                    "path": path,
                }

                depends_on = doc.get("spec", {}).get("dependsOn")
                if not isinstance(depends_on, list):
                    continue
                for dep in depends_on:
                    dep_name = str(dep.get("name", ""))
                    dep_ns = str(dep.get("namespace", namespace))
                    target = node_key(kind, dep_ns, dep_name)
                    edges_by_kind[kind].append((key, target))

    for kind in RESOURCE_KINDS:
        for src, dst in edges_by_kind[kind]:
            if dst not in resources:
                errors.append(f"Missing dependency target: {src} -> {dst}")

    for kind in RESOURCE_KINDS:
        kind_nodes = [k for k, v in resources.items() if v["kind"] == kind]
        cycle = find_cycle(kind_nodes, edges_by_kind[kind])
        if cycle:
            errors.append(f"Cycle detected in {kind}: {' -> '.join(cycle)}")

    dot_output = build_dot(resources, edges_by_kind)

    if args.write_dot:
        with open(args.write_dot, "w", encoding="utf-8") as f:
            f.write(dot_output)

    if args.write_svg:
        dot_path = args.write_dot or os.path.splitext(args.write_svg)[0] + ".dot"
        if not args.write_dot:
            with open(dot_path, "w", encoding="utf-8") as f:
                f.write(dot_output)
        try:
            render_svg(dot_path, args.write_svg)
        except Exception as exc:
            print(f"ERROR: failed to render SVG: {exc}", file=sys.stderr)
            return 1

    if args.write_readme:
        write_readme(args.write_readme, args.write_dot or "cluster/flux/dependencies.dot", args.write_svg or "cluster/flux/dependencies.svg", resources, edges_by_kind)

    if args.check and errors:
        for err in errors:
            print(err, file=sys.stderr)
        return 1

    print(f"Checked {len(resources)} Flux resources")
    print(f"Kustomization edges: {len(edges_by_kind['Kustomization'])}")
    print(f"HelmRelease edges: {len(edges_by_kind['HelmRelease'])}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
